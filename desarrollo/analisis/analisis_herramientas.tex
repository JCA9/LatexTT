\section{Análisis de herramientas a utilizar}
Hemos realizado un análisis de las herramientas que se investigaron para poder dar una solución a la problemática que tenemos,
por lo que a continuación se presentan los resultados de dichas tecnologías.

\subsection{Análisis de los sistemas Operativos}

\begin{itemize}
    \item Windows
    \item Linux
    \item macOS
\end{itemize}

Para el desarrollo del proyecto elegimos Windows como sistema operativo principal, ya que es el que utilizamos en nuestros equipos de trabajo por lo cual ya 
estamos acostumbrados a este sistema y nos ofrece buena compatibilidad con las herramientas de desarrollo. Además, nos facilita la instalación de Android Studio y 
las pruebas locales del proyecto sin complicaciones adicionales.

\subsection{Análisis de los Editores/IDEs}

\begin{itemize}
    \item Visual Studio Code
    \item Android Studio
    \item JetBrains
\end{itemize}

Como entorno de desarrollo se utilizara Visual Studio Code, por ser ligero, rápido y tambien cuenta con una gran cantidad de extensiones que nos facilitaran la 
programación en los diferentes lenguajes que utilizaremos. También nos permite integrar control de versiones, depuración y el trabajo colaborativo sin necesidad de 
herramientas adicionales, ya no tenemos que descargar GitHub o algún otro software.

\subsection{Análisis de los Lenguajes de programación}

En cuanto a los lenguajes de programación, se trabajara con tres principales:

\begin{itemize}
    \item TypeScript
    TypeScript, para el desarrollo del frontend con Next.js por su compatibilidad con React, su tipado estático y su integración natural con VS Code.
    
    \item Dart
    Dart, para el desarrollo móvil con Flutter, debido a su capacidad de compilar de forma nativa para Android.
    
    \item Python
    Python, para los procesos de análisis y extracción de datos, ya que cuenta con librerías muy completas para el manejo de archivos, OCR y automatización.

\end{itemize}

\subsection{Análisis de las Bases de datos}
\begin{itemize}
    \item MySQL
    \item PostgreSQL
    \item MongoDB
\end{itemize}

La base de datos seleccionada fue MySQL, porque es fácil de administrar, tiene buen rendimiento para transacciones y es ampliamente soportada por la mayoría de 
servicios en la nube. Además, nos decidimos por esta ya que es de uso gratuito y contamos con experiencia trabajando en esta base.

\subsection{Análisis de Software para Extracción de Texto}

\begin{itemize}
    \item Tesseract OCR
    \item Paddle OCR
    \item Azure Form Recognizer
\end{itemize}

Para la extracción de texto se optó por Tesseract OCR, por ser una herramienta gratuita, de código abierto y con buena precisión en documentos impresos o escaneados. 
Esto permitió realizar el reconocimiento de texto de los tickets sin depender de servicios externos.

\subsection{Análisis de la Infraestructura en la nube}
\begin{itemize}
    \item Amazon Web Services (AWS)
    \item Microsoft Azure
    \item Google Cloud Platform (GCP)
\end{itemize}
La infraestructura se desplegó en Microsoft Azure, debido a su buena integración con entornos de desarrollo basados en Microsoft, su facilidad para manejar 
contenedores y servicios serverless, y su compatibilidad con bases de datos y análisis en la nube.

\subsection{Análisis de Frameworks frontend web}

\begin{itemize}
    \item Next.js
    \item Remix
    \item SvelteKit
\end{itemize}

En el frontend se eligió Next.js, por su integración directa con React, su rendimiento en renderizado del lado del servidor y su flexibilidad para generar 
páginas estáticas o dinámicas.

\subsection{Análisis de Frameworks móviles}
\begin{itemize}
    \item Flutter
    \item React Native
    \item Kotlin
\end{itemize}

Para la aplicación móvil se utilizó Flutter, ya que permite desarrollar para Android e iOS con una sola base de código y ofrece un rendimiento cercano al nativo.

\subsection{Análisis de Backend}

\begin{itemize}
    \item Node.js con Express
    \item Django
    \item Spring Boot
\end{itemize}

Finalmente, en el backend se implementó Node.js con Express, por su alta velocidad en el manejo de peticiones concurrentes, su compatibilidad con TypeScript y 
la facilidad de crear APIs que se integran directamente con el frontend web y móvil.
